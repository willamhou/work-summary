# 高并发系统设计

高性能、高可用、可扩展



通用设计方法

* 横向扩展
* 缓存
* 异步

可用性指标:

​	平均故障间隔时间

​    平均故障回复时间

​    可用性  =  平均故障间隔时间/(平均故障间隔时间 + 平均故障回复时间)

## 数据库优化

* 连接池
* 主从读写分离
  * 主库写入, 从库读取. 主库binglog中的异步log dump线程同步给从库的IO线程, relaylog负责读取写入从库
  * 监控主从同步的延迟时间, 一般ms级别
    * 从库延迟可以通过缓存或者数据冗余解决
  * 通过数据库中间件访问数据库
  * 主从节点一致性和写入性能的权衡 ---- 优先保证性能,不考虑强一致性
  * 主从延迟问题,需要进行监控
* 分库分表
  * 数据库拆分
    * 垂直拆分
      * 将数据库的表拆到不同的数据库中
      * 一般原则是按照业务类型拆分, 核心思想是专库专用, 将业务耦合度比极高的表拆分到单独的库中
    * 水平拆分
      * 将单一的数据表按照某一种原则拆分到多个数据库和多个数据表中,关注点是数据的特点
      * 拆分规则
        * 按照字段的哈希值进行拆分, 这种拆分规则适用于实体表. 比如说用户表、内容表.按照实体表的ID字段进行拆分. db_id = hash(id)%db_size table_id = hash(id)%table_size
        * 另外一种比较常用的是按照某一个字段的区间来拆分, 比较常用的是时间字段. 一般来说列表键可以使用这种拆分方式
  * 拆分后引入的问题
    * 引入了分库分表键, 即分区键
    * 数据库的一些特性无法使用, 比如Join
    * 解决方法
      * 做分区键的映射表
      * 业务逻辑处理一些数据库特性
      * 引入其他方案, 比如利用redis来解决计数方案
  * 分库分表的原则
    * 如果没有性能瓶颈, 尽量不使用分库分表
      * 写性能瓶颈考虑使用分库分表
      * 读性能瓶颈考虑用ES或者其他方式重构
    * 如果使用分库分表, 则尽量一次性做到位
    * 利用NoSQL代替关系型数据库
  * 数据迁移的方法
    * 数据迁移一般是先双写旧库和新库,然后校验数据,然后灰度切读,最后全量切读,注意点就是数据校验过程,会比较繁琐
  * 数据库主键的选择
    * 利用生成的ID做数据主键
    * 单库单表的情形下使用数据库自增字段作为ID
    * 基于SnowFlake算法搭建发号器
      * 生成ID最好是单调有序
      * ID有序有利于数据库写入性能
      * Snowflake 的核心思想是将 64bit 的二进制数字分成若干部分,每一部分都存储有特定含义的数据
      * 实现方式
        * 嵌入到业务服务器中
        * 作为独立的服务器部署, 发号服务器
        * 时间戳记录秒而不记录毫秒, 一个时间区间里可以多发出几个号码,避免出现分库分表时数据分配不均匀
        * 生成的序列号起始号可以做一下随机, 尽量均衡

## 缓存篇

读写策略

* 旁路(Cache Side)策略 （分布式缓存经常使用）

  ![](https://static001.geekbang.org/resource/image/66/c4/661da5a2b55b7d6e1575a3241247eec4.jpg)

  * 读策略
    * 从缓存中读取数据
    * 如果缓存命中,则直接返回数据
    * 如果缓存不命中,则从数据库中查询数据
    * 查询到数据后,将数据写入到缓存中,并且返回给用户
  * 写策略
    * 更新数据库中的记录
    * 删除缓存
    * 缓存的写入速度通常远远快于数据库的写入速度
  * 问题
    * 写入比较频繁的时候,缓存中的数据会被经常清理, 对缓存命中率有一些影响
    * 解决方案
      * 更新数据时也更新缓存, 利用分布式锁避免竞争,对写入性能有影响
      * 更新数据时也更新缓存,给缓存加一个较短的过期时间.即使出现缓存不一致的情况,缓存的数据也会很快过期

* Read/Write Through 和 Write Back(本地缓存使用)

* Write Back(计算机体系结构的缓存策略)

缓存高可用

* 客户端方案

  * 写入时的数据分片
    * Hash分片算法
      * 对缓存的Key做Hash运算, 然后对总的缓存节点个数取余
      * 缺点:增加或者减少缓存节点的时候,造成计算出来的节点发生变化,导致缓存失效不可用
    * 一致性Hash算法
      * 缺点
        * 脏数据问题:节点故障时候的数据更新不及时
        * 缓存节点在圆环上分布不均匀,造成部分节点的缓存压力较大;当某个节点故障时,这个节点承担的所有访问都很被顺移到另一个节点上,会对后面的节点造成较大的压力
      * 解决
        * 脏数据问题:设置缓存的过期时间,减少脏数据的几率
        * 压力不均匀问题: 引入虚拟节点, 将一个缓存节点计算多个Hash值分散到圆环的不同位置.可以实现数据的平均,同时在了一个节点故障或者退出的时候,原先承担的key更均匀的分配到其他节点上,从而避免雪崩.

  * 读取时的多组缓存容错
    * 主从
      * Memecache
        * Master + Slave
        * 更新的时候, 主从同步更新
        * 读取的时候, 先读取slave, 如果slave不存在, 再去Master读取
      * 多副本

* 中间代理层方案

  * codis

* 服务端方案

  * Redis-Sentinel
  * Redis-Cluster

缓存穿透

* 定义:查询一个一定不存在的数据,由于缓存是不命中时需要从数据库查询,查不到数据则不写入缓存,这将导致这个不存在的数据每次请求都要到数据库去查询,造成缓存穿透
* 解决方案:
  * 回空值, 如果查询到为空, 则直接将该key设置成空并且设置一个不太长的过期时间
  * 布隆过滤器
    * 特点:在不一定在,不在一定不在
    * 对一个key使用多个hash函数,将对应的位置设置成1