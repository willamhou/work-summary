# Redis

## Redis  5种基础数据结构

* 字符串 (string)

  编码

  * 整数值  --- int
  * 字符串值且字符串长度<=39个字节 --- embstr
  * 字符串值且字符串长度大于39个字节 --- raw, 利用sds保存
    * sds 采用预分配冗余空间的方式来减少内存的频繁分配.sds的分配的内存空间capacity一般要高于实际字符串长度len
    * 当sds字符串长度小于1MB的时候, 扩容是加倍扩容. 当sds字符串长度大于1MB的时候, 每次只扩容1MB空间
    * 字符串长度最大为512M

* 列表 (list)

  编码

  * ziplist约束
    * 列表对象保存的所有字符串元素的长度都小于64字节
    * 列表对象保存的元素数量小于512个
    * 不能满足上述两个条件的使用linkedList编码
  * linkedlist
    * 双向list

  可以用来做异步队列使用, 将需要延后处理的任务结构体序列化存储成字符串, 存储到Redis列表中. 另外一个线程从这个列表中轮询数据进行处理.

* 字典 (hash)

  编码

  * ziplist约束

    * 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
    * 哈希对象保存的键值对数量小于512个

  * hashtable

    * 索引计算

      ~~~C++
      hash = dict->type->hashFunction(key)
      
      index = hash & dict->ht[x].sizemask; // sizemask 总是等于哈希表的size - 1
      ~~~

    * 键冲突利用链地址法来解决冲突, 新节点总是直接插入到表头位置

    * rehash

      * 采用了渐进式rehash的策略, 是为了避免直接rehash过程中, hashtable键值对数量过大阻塞服务.

      * 哈希表的扩容与收缩

        * 服务没有执行持久化操作且负载因子大于等于1, 执行扩容
        * 服务有执行持久化操作且负载因子大于等于5, 执行扩容

        ~~~C++
        load_factor = ht[0].used / ht[0].size
        ~~~

        * 负载因子小于0.1的时候, 执行收缩操作

      * 渐进式rehash的过程中, 字典的删除、更新和查找会同时在2个哈希表中进行, 而新添加的键值对一律会被保存到ht[1]中,这一操作保证了ht[0]中的键值对只减不增, 并随着rehash的执行逐渐变成空表

* 集合 (set)

  编码

  * intset约束
    * 集合对象保存的所有元素值都是整数值
    * 集合元素对象保存的元素数量不超过512个(上限512可以修改)
  * hashtable

* 有序集合 (zset)

  编码

  * ziplist约束条件

    * 有序集合保存的元素数量小于128个
    * 有序集合保存的所有元素的的长度都小于64字节

  * skiplist

    * 使用zset有序集合实现, zset包含一个跳表和一个字典

      ~~~c++
      typedef struct zset {
          dict *dict;
          zskiplist *zsl;
      } zset;
      ~~~

    * 字典的键保存了元素的成员, 值保存了元素的分值. 提供了O(1)查找给定成员分值的能力

    * 跳表的object属性保存了元素的成员, 而score保存了元素的分值,提供了范围查找的能力

    * 字典和跳跃表通过指针来共享元素的成员和分值, 因此不会产生重复的成员或者分值,也不会因此浪费内存

  

## Redis持久化策略

默认支持如下两种持久化策略. 由于AOF的更新频率比RDB的更新频率高, 在开启了AOF持久化的功能时,使用AOF持久化. 否则, 使用RDB持久化.

* RDB持久化

  * SAVE 阻塞服务器进程, 直到RDB文件创建完毕

  * BGSAVE 派生出子进程,然后由子进程负责创建RDB文件, 父进程继续处理请求

    * BGSAVE执行期间, 客户端发送的SAVE和BGSAVE命令都会被拒绝, 防止数据竞争
    * BGSAVE与BGREWRITEAOF命令会被延迟到BGSAVE执行完成以后在执行
    * 如果BGREWRITEAOF命令正在执行,则客户端发送的BGSAVE命令会被拒绝

  * 生成RDB文件的时候, 已经过期的键不会被保存到新创建的RDB文件中.

  * 服务器载入RDB文件的时候, 会一直处于阻塞状态,直到载入工作完成为止. 

    * 主服务器载入时, 过期的键不会被载入
    * 从服务器载入时, 无论过期还是不过期,都会被载入. 但是主从服务器进行数据同步的时候,从服务器的数据会被清空.因此过期键对从服务器没有影响

  * 自动间隔性保存

    * redis允许用户通过配置设置服务器save选项,让服务器间隔执行一次BGSAVE命令

      ~~~c++
      save 900 1
      save 300 10
      save 60 10000
      ~~~

* AOF持久化

  * 命令追加

    * 写入aof缓冲区, 是一个sds字符串

  * 文件写入和同步

    * 服务器在每一个事件循环结束前, 调用flushAppendOnlyFile函数,考虑是否将aof_buf中的内容写入和保存到AOF文件中
      * always  --- 将aof缓冲区所有内容写入并同步到AOF文件
      * everysec --- 将aof缓冲区内容写入到aof文件, 如果上次aof文件的时间距离现在超过1s, 再次对AOF文件进行同步.同步操作由专门的线程
      * no --- 将aof缓冲内容写入到aof文件, 但是不对AOF文件进行同步,何时同步由操作系统决定.

  * AOF重写

    AOF持久化是通过保存被执行的命令来记录数据库状态的.随着时间的流逝, AOF的内容会越来越多,体积会越来越庞大.

    AOF重写可以创建一个新的AOF文件来替代现有的文件,新旧两个文件保存的数据库状态相同.但新的AOF文件不会包含浪费空间的冗余命令,要比旧文件少的体积少很多.

    原理

    * AOF重写不需要对现有的AOF文件进行任何读取、分析或者写入操作.通过读取当前服务器当前的数据库状态来实现的

    * 首先冲数据库中读取键现在的值, 然后用一条命令去记录键值对,代替之前记录这个键值对的多条命令

  * AOF后台重写

    * 子进程进行AOF重写工作
    * 利用AOF重写缓冲区保证子进程和父进程的数据一致性. 父进程执行客户端发送完的命令后,将执行后的命令写入AOF缓冲区, 将执行后的写命令写入AOF重写缓冲区.
    * 子进程完成AOF重写操作后,发送信号父进程.父进程调用信号处理函数,并完成以下工作
      * 将AOF重写缓冲区的内容写入AOF文件,AOF文件中保存的数据库的状态同数据库状态一致
      * 对新的AOF文件进行改名,原子化的替换旧的AOF文件

  * AOF过期键的处理

    * AOF重写过程中已过期的键不会被写入到AOF文件中
    * AOF写入过程中,如果一个过期键没有被删除不会对AOF有任何影响;如果被删除,则会被追加一个命令显式删除.

